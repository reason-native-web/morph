<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Logs (logs.Logs)</title><link rel="stylesheet" href="../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">logs</a> &#x00BB; Logs</nav><h1>Module <code>Logs</code></h1><p>Logging.</p><p><code>Logs</code> provides a basic logging infrastructure. <a href="index.html#func"><span>Logging</span></a> is performed on <a href="index.html#srcs"><span>sources</span></a> whose reporting <a href="index.html#type-level"><span>level</span></a> can be set independently. Log message report is decoupled from logging and handled by a <a href="index.html#reporters"><span>reporter</span></a>.</p><p>See the <a href="index.html#basics"><span>basics</span></a>, a few <a href="index.html#usage"><span>usage conventions</span></a> to respect and a note on <a href="index.html#sync"><span>synchronous logging</span></a>.</p><p><em>v0.7.0 - <a href="https://erratique.ch/software/logs">homepage</a></em></p><nav class="toc"><ul><li><a href="#levels">Reporting levels</a></li><li><a href="#srcs">Log sources</a></li><li><a href="#func">Log functions</a><ul><li><a href="#result">Logging <code>result</code> value <code>Error</code>s</a></li></ul></li><li><a href="#srcfunc">Source specific log functions</a></li><li><a href="#reporters">Reporters</a></li><li><a href="#monitoring">Logs monitoring</a></li><li><a href="#basics">Basics</a><ul><li><a href="#logging">Logging</a></li><li><a href="#setupreporter">Reporter setup</a></li></ul></li><li><a href="#usage">Usage conventions</a></li><li><a href="#sync">Note on synchronous logging</a></li><li><a href="#ex1">Example with custom reporter and tags</a></li><li><a href="#ex2">Logging to multiple reporters</a></li></ul></nav></header><section><header><h2 id="levels"><a href="#levels" class="anchor"></a>Reporting levels</h2></header><dl><dt class="spec type" id="type-level"><a href="#type-level" class="anchor"></a><code><span class="keyword">type</span> level</code><code> = </code><table class="variant"><tr id="type-level.App" class="anchored"><td class="def constructor"><a href="#type-level.App" class="anchor"></a><code>| </code><code><span class="constructor">App</span></code></td></tr><tr id="type-level.Error" class="anchored"><td class="def constructor"><a href="#type-level.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span></code></td></tr><tr id="type-level.Warning" class="anchored"><td class="def constructor"><a href="#type-level.Warning" class="anchor"></a><code>| </code><code><span class="constructor">Warning</span></code></td></tr><tr id="type-level.Info" class="anchored"><td class="def constructor"><a href="#type-level.Info" class="anchor"></a><code>| </code><code><span class="constructor">Info</span></code></td></tr><tr id="type-level.Debug" class="anchored"><td class="def constructor"><a href="#type-level.Debug" class="anchor"></a><code>| </code><code><span class="constructor">Debug</span></code></td></tr></table></dt><dd><p>The type for reporting levels. For level semantics see the <a href="index.html#usage"><span>usage conventions</span></a>.</p><p>Log <a href="index.html#srcs"><span>sources</span></a> have an optional <a href="Src/index.html#val-level"><span>reporting level</span></a>. If the level is <code>Some l</code> then any message whose level is smaller or equal to <code>l</code> is reported. If the level is <code>None</code> no message is ever reported.</p></dd></dl><dl><dt class="spec value" id="val-level"><a href="#val-level" class="anchor"></a><code><span class="keyword">val</span> level : unit <span>&#45;&gt;</span> <span><a href="index.html#type-level">level</a> option</span></code></dt><dd><p><code>level ()</code> is the reporting level given to <a href="Src/index.html#val-create"><span>new sources</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_level"><a href="#val-set_level" class="anchor"></a><code><span class="keyword">val</span> set_level : <span>?&#8288;all:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-level">level</a> option</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_level ?all l</code> sets the reporting level given to <a href="Src/index.html#val-create"><span>new sources</span></a>. If <code>all</code> is <code>true</code> (default), also sets the reporting level of all <a href="Src/index.html#val-list"><span>existing sources</span></a>. Use <a href="Src/index.html#val-set_level"><code>Src.set_level</code></a> to only affect a specific source. Only applications should use this function directly see <a href="index.html#usage"><span>usage conventions</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp_level"><a href="#val-pp_level" class="anchor"></a><code><span class="keyword">val</span> pp_level : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-level">level</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_level ppf l</code> prints an unspecified representation of <code>l</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-level_to_string"><a href="#val-level_to_string" class="anchor"></a><code><span class="keyword">val</span> level_to_string : <span><a href="index.html#type-level">level</a> option</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>level_to_string l</code> converts <code>l</code> to an US-ASCII string that can be parsed back by <a href="index.html#val-level_of_string"><code>level_of_string</code></a> and by the <code>LEVEL</code> option argument of <a href="../Logs_cli/index.html#val-level"><code>Logs_cli.level</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-level_of_string"><a href="#val-level_of_string" class="anchor"></a><code><span class="keyword">val</span> level_of_string : string <span>&#45;&gt;</span> <span><span>(<span><a href="index.html#type-level">level</a> option</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>level_of_string s</code> parses the representation of <a href="index.html#val-level_to_string"><code>level_to_string</code></a> from <code>s</code>.</p></dd></dl></section><section><header><h2 id="srcs"><a href="#srcs" class="anchor"></a>Log sources</h2></header><dl><dt class="spec type" id="type-src"><a href="#type-src" class="anchor"></a><code><span class="keyword">type</span> src</code></dt><dd><p>The type for log sources. A source defines a named unit of logging whose reporting level can be set independently.</p></dd></dl><dl><dt class="spec value" id="val-default"><a href="#val-default" class="anchor"></a><code><span class="keyword">val</span> default : <a href="index.html#type-src">src</a></code></dt><dd><p><code>default</code> is a logging source that is reserved for use by applications. See <a href="index.html#usage"><span>usage conventions</span></a>.</p></dd></dl><dl><dt class="spec module" id="module-Src"><a href="#module-Src" class="anchor"></a><code><span class="keyword">module</span> <a href="Src/index.html">Src</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sources.</p></dd></dl></section><section><header><h2 id="func"><a href="#func" class="anchor"></a>Log functions</h2></header><dl><dt class="spec module" id="module-Tag"><a href="#module-Tag" class="anchor"></a><code><span class="keyword">module</span> <a href="Tag/index.html">Tag</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Message tags.</p></dd></dl><dl><dt class="spec type" id="type-msgf"><a href="#type-msgf" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) msgf</span></code><code> = <span>(<span>?&#8288;header:string</span> <span>&#45;&gt;</span> <span>?&#8288;tags:<a href="Tag/index.html#type-set">Tag.set</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, Stdlib.Format.formatter, unit, <span class="type-var">'b</span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>The type for client specified message formatting functions.</p><p>Message formatting functions are called with a message construction function whenever a message needs to be reported. The message formatting function must call the given message construction function with a format string and its arguments to define the message contents, see the <a href="index.html#logging"><span>basics</span></a> for examples. The optional arguments of the message construction function are:</p><ul><li><code>header</code>, an optional printable message header. Default to <code>None</code>.</li><li><code>tags</code>, a set of tags to attach to the message. Defaults <a href="Tag/index.html#val-empty"><code>Tag.empty</code></a>.</li></ul></dd></dl><dl><dt class="spec type" id="type-log"><a href="#type-log" class="anchor"></a><code><span class="keyword">type</span> <span>'a log</span></code><code> = <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="index.html#type-msgf">msgf</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>The type for log functions. See the <a href="index.html#logging"><span>basics</span></a> to understand how to use log functions.</p></dd></dl><dl><dt class="spec value" id="val-msg"><a href="#val-msg" class="anchor"></a><code><span class="keyword">val</span> msg : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <a href="index.html#type-level">level</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-log">log</a></span></code></dt><dd><p><code>msg ?src l (fun m -&gt; m fmt ...)</code> logs with level <code>l</code> on the source <code>src</code> (defaults to <a href="index.html#val-default"><code>default</code></a>) a message formatted with <code>fmt</code>. For the semantics of levels see the <a href="index.html#usage"><span>the usage conventions</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val</span> app : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-log">log</a></span></code></dt><dd><p><code>app</code> is <code>msg App</code>.</p></dd></dl><dl><dt class="spec value" id="val-err"><a href="#val-err" class="anchor"></a><code><span class="keyword">val</span> err : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-log">log</a></span></code></dt><dd><p><code>err</code> is <code>msg Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-warn"><a href="#val-warn" class="anchor"></a><code><span class="keyword">val</span> warn : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-log">log</a></span></code></dt><dd><p><code>warn</code> is <code>msg Warning</code>.</p></dd></dl><dl><dt class="spec value" id="val-info"><a href="#val-info" class="anchor"></a><code><span class="keyword">val</span> info : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-log">log</a></span></code></dt><dd><p><code>info</code> is <code>msg Info</code>.</p></dd></dl><dl><dt class="spec value" id="val-debug"><a href="#val-debug" class="anchor"></a><code><span class="keyword">val</span> debug : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-log">log</a></span></code></dt><dd><p><code>debug</code> is <code>msg Debug</code>.</p></dd></dl><dl><dt class="spec value" id="val-kmsg"><a href="#val-kmsg" class="anchor"></a><code><span class="keyword">val</span> kmsg : <span>(unit <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <a href="index.html#type-level">level</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-msgf">msgf</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>kmsg k</code> is like <a href="index.html#val-msg"><code>msg</code></a> but calls <code>k</code> for returning.</p></dd></dl><section><header><h3 id="result"><a href="#result" class="anchor"></a>Logging <code>result</code> value <code>Error</code>s</h3></header><dl><dt class="spec value" id="val-on_error"><a href="#val-on_error" class="anchor"></a><code><span class="keyword">val</span> on_error : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span>?&#8288;level:<a href="index.html#type-level">level</a></span> <span>&#45;&gt;</span> <span>?&#8288;header:string</span> <span>&#45;&gt;</span> <span>?&#8288;tags:<a href="Tag/index.html#type-set">Tag.set</a></span> <span>&#45;&gt;</span> <span>pp:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>use:<span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> Stdlib.result</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>on_error ~level ~pp ~use r</code> is:</p><ul><li><code>v</code> if <code>r = Ok v</code></li><li><code>use e</code> if <code>r = Error e</code>. As a side effect <code>msg</code> is logged with <code>pp</code> on level <code>level</code> (defaults to <a href="index.html#type-level.Error"><code>Logs.level.Error</code></a>).</li></ul></dd></dl><dl><dt class="spec value" id="val-on_error_msg"><a href="#val-on_error_msg" class="anchor"></a><code><span class="keyword">val</span> on_error_msg : <span>?&#8288;src:<a href="index.html#type-src">src</a></span> <span>&#45;&gt;</span> <span>?&#8288;level:<a href="index.html#type-level">level</a></span> <span>&#45;&gt;</span> <span>?&#8288;header:string</span> <span>&#45;&gt;</span> <span>?&#8288;tags:<a href="Tag/index.html#type-set">Tag.set</a></span> <span>&#45;&gt;</span> <span>use:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>on_error_msg</code> is like <a href="index.html#val-on_error"><code>on_error</code></a> but uses <span class="xref-unresolved" title="unresolved reference to &quot;Format.pp_print_text&quot;"><code>Format</code>.pp_print_text</span> to format the message.</p></dd></dl></section></section><section><header><h2 id="srcfunc"><a href="#srcfunc" class="anchor"></a>Source specific log functions</h2></header><dl><dt class="spec module-type" id="module-type-LOG"><a href="#module-type-LOG" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LOG/index.html">LOG</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The type for source specific logging functions.</p></dd></dl><dl><dt class="spec value" id="val-src_log"><a href="#val-src_log" class="anchor"></a><code><span class="keyword">val</span> src_log : <a href="index.html#type-src">src</a> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-LOG/index.html">LOG</a>)</span></code></dt><dd><p><code>src_log src</code> is a <a href="module-type-LOG/index.html"><span>set of logging functions</span></a> for <code>src</code>.</p></dd></dl></section><section><header><h2 id="reporters"><a href="#reporters" class="anchor"></a>Reporters</h2></header><dl><dt class="spec type" id="type-reporter"><a href="#type-reporter" class="anchor"></a><code><span class="keyword">type</span> reporter</code><code> = </code><code>{</code><table class="record"><tr id="type-reporter.report" class="anchored"><td class="def field"><a href="#type-reporter.report" class="anchor"></a><code>report : a b. <a href="index.html#type-src">src</a> <span>&#45;&gt;</span> <a href="index.html#type-level">level</a> <span>&#45;&gt;</span> <span>over:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-msgf">msgf</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr></table><code>}</code></dt><dd><p>The type for reporters.</p><p>A reporter formats and handles log messages that get reported. Whenever a <a href="index.html#func"><span>log function</span></a> gets called on a source with a level equal or smaller to the <a href="Src/index.html#val-level"><span>source's reporting level</span></a>, the <a href="index.html#type-reporter"><span>current reporter</span></a>'s field <code>r.report</code> gets called as <code>r.report src level ~over k msgf</code> where:</p><ul><li><code>src</code> is the logging source.</li><li><code>level</code> is the reporting level.</li><li><code>over</code> must be called by the reporter once the logging operation is over from the reporter's perspective. This may happen before or after <code>k</code> is called.</li><li><code>k</code> is the function to invoke to return.</li><li><code>msgf</code> is the <a href="index.html#type-msgf"><span>message formatting function</span></a> to call.</li></ul><p>See an <a href="index.html#ex1"><span>example</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-nop_reporter"><a href="#val-nop_reporter" class="anchor"></a><code><span class="keyword">val</span> nop_reporter : <a href="index.html#type-reporter">reporter</a></code></dt><dd><p><code>nop_reporter</code> is the initial reporter returned by <a href="index.html#type-reporter"><code>reporter</code></a>, it does nothing if a log message gets reported.</p></dd></dl><dl><dt class="spec value" id="val-format_reporter"><a href="#val-format_reporter" class="anchor"></a><code><span class="keyword">val</span> format_reporter : <span>?&#8288;pp_header:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<a href="index.html#type-level">level</a> * <span>string option</span>)</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;app:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> <span>?&#8288;dst:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-reporter">reporter</a></code></dt><dd><p><code>format_reporter ~pp_header ~app ~dst ()</code> is a reporter that reports <a href="index.html#type-level.App"><code>App</code></a> level messages on <code>app</code> (defauts to <span class="xref-unresolved" title="unresolved reference to &quot;Format.std_formatter&quot;"><code>Format</code>.std_formatter</span>) and all other level on <code>dst</code> (defaults to <span class="xref-unresolved" title="unresolved reference to &quot;Format.err_formatter&quot;"><code>Format</code>.err_formatter</span>).</p><p><code>pp_header</code> determines how message headers are rendered. The default prefixes the program name and renders the header with <a href="index.html#val-pp_header"><code>pp_header</code></a>. Use <a href="../Logs_fmt/index.html#reporter"><span>Reporter</span></a> if you want colored headers rendering.</p><p>The reporter does not process or render information about message sources or tags.</p><p><b>Important.</b> This is a synchronous reporter it considers the log operation to be over once the message was formatted and before calling the continuation (see the <a href="index.html#sync"><span>note on synchronous logging</span></a>). In particular if the formatters are backed by channels, it will block until the message has been formatted on the channel before proceeding which may not be suitable in a cooperative concurrency setting like <a href="../../lwt/Lwt/index.html"><code>Lwt</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-reporter"><a href="#val-reporter" class="anchor"></a><code><span class="keyword">val</span> reporter : unit <span>&#45;&gt;</span> <a href="index.html#type-reporter">reporter</a></code></dt><dd><p><code>reporter ()</code> is the current repporter.</p></dd></dl><dl><dt class="spec value" id="val-set_reporter"><a href="#val-set_reporter" class="anchor"></a><code><span class="keyword">val</span> set_reporter : <a href="index.html#type-reporter">reporter</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_reporter r</code> sets the current reporter to <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_reporter_mutex"><a href="#val-set_reporter_mutex" class="anchor"></a><code><span class="keyword">val</span> set_reporter_mutex : <span>lock:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>unlock:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_reporter_mutex ~lock ~unlock</code> sets the mutex primitives used to access the reporter. <code>lock</code> is called before invoking the reporter and <code>unlock</code> after it returns. Initially both <code>lock</code> and <code>unlock</code> are <code>fun () -&gt; ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-pp_header"><a href="#val-pp_header" class="anchor"></a><code><span class="keyword">val</span> pp_header : Stdlib.Format.formatter <span>&#45;&gt;</span> <span>(<a href="index.html#type-level">level</a> * <span>string option</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_header ppf (l, h)</code> prints an unspecified representation of log header <code>h</code> for level <code>l</code>.</p></dd></dl></section><section><header><h2 id="monitoring"><a href="#monitoring" class="anchor"></a>Logs monitoring</h2></header><dl><dt class="spec value" id="val-err_count"><a href="#val-err_count" class="anchor"></a><code><span class="keyword">val</span> err_count : unit <span>&#45;&gt;</span> int</code></dt><dd><p><code>err_count ()</code> is the number of messages logged with level <code>Error</code> across all sources.</p></dd></dl><dl><dt class="spec value" id="val-warn_count"><a href="#val-warn_count" class="anchor"></a><code><span class="keyword">val</span> warn_count : unit <span>&#45;&gt;</span> int</code></dt><dd><p><code>warn_count ()</code> is the number of messages logged with level <code>Warning</code> across all sources.</p></dd></dl></section><section><header><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2></header><section><header><h3 id="logging"><a href="#logging" class="anchor"></a>Logging</h3><p>In order to minimize the overhead whenever a log message is not reported, message formatting only occurs on actual message report via the <a href="index.html#type-msgf"><span>message formatting function</span></a> you provide to log functions. This leads to the following logging structure:</p><pre><code class="ml">let k, v = ... in
Logs.err (fun m -&gt; m &quot;invalid kv (%a,%a)&quot; pp_key k pp_val v);
Logs.err (fun m -&gt; m &quot;NO CARRIER&quot;);</code></pre><p>The pattern is quite simple: it is as if you were formatting with a <code>printf</code>-like function except you get this function in the <code>m</code> argument of the function you give to the logging function.</p><p>If you want to abstract a repeated log report it is better to keep the message formatting function structure for the arguments of the messages. Here's how the above examples can be abstracted and invoked:</p><pre><code class="ml">let err_invalid_kv args =
  Logs.err @@ fun m -&gt;
  args (fun k v -&gt; m &quot;invalid kv (%a,%a)&quot; pp_key k pp_val v)

let err_no_carrier args =
  Logs.err @@ fun m -&gt; args (m &quot;NO CARRIER&quot;)

let () =
  err_invalid_kv (fun args -&gt; args &quot;key&quot; &quot;value&quot;);
  err_no_carrier (fun () -&gt; ());
  ()</code></pre><p>Note that log messages are formatted and hit the reporter only if they have not been filtered out by the current <a href="Src/index.html#val-level"><span>reporting level</span></a> of the source you log on. See also the log source and reporting level <a href="index.html#usage"><span>usage conventions</span></a>.</p></header></section><section><header><h3 id="setupreporter"><a href="#setupreporter" class="anchor"></a>Reporter setup</h3><p>If you are writing an application you must remember to <a href="index.html#val-set_reporter"><span>set</span></a> the reporter before any logging operation takes place otherwise no messages will be reported. For example if you are using the <a href="../Logs_fmt/index.html"><span>formatter reporter</span></a>, logging can be setup as follows:</p><pre><code class="ml">let main () =
  Logs.set_reporter (Logs_fmt.reporter ());
  ...
  exit (if Logs.err_count () &gt; 0 then 1 else 0);
  ()</code></pre><p>If you have logging code that is performed in the toplevel initialization code of modules (not a good idea) or you depend on (bad) libraries that do so, you must call and link the reporter install code before these initialization bits are being executed otherwise you will miss these messages.</p><p>In multi-threaded programs you likely want to ensure mutual exclusion on reporter access. This can be done by invoking <a href="index.html#val-set_reporter_mutex"><code>Logs.set_reporter_mutex</code></a> with suitable mutual exclusion primitives. If you use OCaml <code>Thread</code>s simply calling <a href="../Logs_threaded/index.html#val-enable"><code>Logs_threaded.enable</code></a> with handle that for you.</p><p>If you need to use multiple reporters in your program see this <a href="index.html#ex2"><span>sample code</span></a>.</p><p>The documentation of <a href="../Logs_cli/index.html"><code>Logs_cli</code></a> module has a <a href="../Logs_cli/index.html#ex"><span>full setup example</span></a> that includes command line options to control color and log reporting level.</p><p>If you are writing a library you should neither install reporters, nor set the reporting level of sources, nor log on the <a href="index.html#val-default"><code>default</code></a> source or at the <code>App</code> level; follow the <a href="index.html#usage"><span>the usage conventions</span></a>. A library should simply log on another existing source or define its own source like in the example below:</p><pre><code class="ml">let src = Logs.Src.create &quot;mylib.network&quot; ~doc:&quot;logs mylib's network events&quot;
module Log = (val Logs.src_log src : Logs.LOG)</code></pre><p>The <code>Log</code> module defines logging functions that are specific to the source <code>src</code>.</p></header></section></section><section><header><h2 id="usage"><a href="#usage" class="anchor"></a>Usage conventions</h2><p>A library should never log on the <a href="index.html#val-default"><code>default</code></a> source or at the <code>App</code> level these are reserved for use by the application. It should either create a source for itself or log on the source defined by one of its dependencies. It should also never set the reporting level of the sources it deals with or install reporters since control over this must be left to the application.</p><p>The semantics of <a href="index.html#type-level"><span>reporting levels</span></a> should be understood as follows:</p><ul><li><code>App</code>, this level can be used for the standard output or console of an application. It should never be used by libraries.</li><li><code>Error</code>, error condition that prevent the program from running normally.</li><li><code>Warning</code>, suspicious condition that does not prevent the program from running normally but may eventually lead to an error condition.</li><li><code>Info</code>, condition that allows the program <em>user</em> to get a better understanding of what the program is doing.</li><li><code>Debug</code>, condition that allows the program <em>developer</em> to get a better undersanding of what the program is doing.</li></ul></header></section><section><header><h2 id="sync"><a href="#sync" class="anchor"></a>Note on synchronous logging</h2><p>In synchronous logging, a client call to a log function proceeds only once the reporter has finished the report operation. In <code>Logs</code> this depends both on the reporter and the log functions that the client uses.</p><p>Whenever the client uses a log function that results in a report, it gives the reporter a continuation that defines the result type of the log function and a callback to be called whenever the log operation is over from the reporter's perspective (see <a href="index.html#type-reporter"><code>reporter</code></a>). The typical use of the callback is to unblock the continuation given to the reporter. This is used by <a href="../Logs_lwt/index.html"><code>Logs_lwt</code></a>'s log functions to make sure that the threads they return proceed only once the report is over. In the functions of <a href="index.html"><code>Logs</code></a> however the callback does nothing as there is no way to block the polymorphic continuation.</p><p>Now considering reporters, at the extreme we have:</p><ul><li>A completely asynchronous reporter. This reporter formats the message in memory and immediately invoke the callback followed by the continuation. This provides no guarantee of persistency in case a crash occurs. All log functions behave asynchronously and return as soon as possible.</li><li>A completely synchronous reporter. This reporter formats the message, persist it, invoke the client callback followed by the continuation. All log functions behave synchronously. An example of such a reporter is <a href="../Logs_fmt/index.html#reporter"><span>Reporter</span></a> with formatters baked by channels: when formatting returns the message has been written on the channel.</li></ul><p>However a purely synchronous reporter like <a href="../Logs_fmt/index.html#reporter"><span>Reporter</span></a> acting on channels does not play well with <code>Lwt</code>'s cooperative runtime system. It is possible to reuse <a href="../Logs_fmt/index.html#reporter"><span>Reporter</span></a> to define a cooperative reporter, see <a href="../Logs_lwt/index.html#report_ex"><span>this example</span></a>. However while this reporter makes <a href="../Logs_lwt/index.html"><code>Logs_lwt</code></a>'s log functions synchronous, those of <a href="index.html"><code>Logs</code></a> behave asynchronously. For now it seems it that this is unfortunately the best we can do if we want to preserve the ability to use <code>Logs</code> with or without cooperative concurency.</p></header></section><section><header><h2 id="ex1"><a href="#ex1" class="anchor"></a>Example with custom reporter and tags</h2><p>This example uses a <a href="Tag/index.html"><span>tag</span></a> to attach <code>Mtime</code> time spans in log messages. The custom reporter uses these time spans to format relative timings for runs of a given function. Note that as done below the timings do include logging time.</p><pre><code class="ml">let stamp_tag : Mtime.span Logs.Tag.def =
  Logs.Tag.def &quot;stamp&quot; ~doc:&quot;Relative monotonic time stamp&quot; Mtime.Span.pp

let stamp c = Logs.Tag.(empty |&gt; add stamp_tag (Mtime_clock.count c))

let run () =
  let rec wait n = if n = 0 then () else wait (n - 1) in
  let c = Mtime_clock.counter () in
  Logs.info (fun m -&gt; m &quot;Starting run&quot;);
  let delay1, delay2, delay3 = 10_000, 20_000, 40_000 in
  Logs.info (fun m -&gt; m &quot;Start action 1 (%d).&quot; delay1 ~tags:(stamp c));
  wait delay1;
  Logs.info (fun m -&gt; m &quot;Start action 2 (%d).&quot; delay2 ~tags:(stamp c));
  wait delay2;
  Logs.info (fun m -&gt; m &quot;Start action 3 (%d).&quot; delay3 ~tags:(stamp c));
  wait delay3;
  Logs.info (fun m -&gt; m &quot;Done.&quot; ?header:None ~tags:(stamp c));
  ()

let reporter ppf =
  let report src level ~over k msgf =
    let k _ = over (); k () in
    let with_stamp h tags k ppf fmt =
      let stamp = match tags with
      | None -&gt; None
      | Some tags -&gt; Logs.Tag.find stamp_tag tags
      in
      let dt = match stamp with None -&gt; 0. | Some s -&gt; Mtime.Span.to_us s in
      Format.kfprintf k ppf (&quot;%a[%0+04.0fus] @[&quot; ^^ fmt ^^ &quot;@]@.&quot;)
        Logs.pp_header (level, h) dt
    in
    msgf @@ fun ?header ?tags fmt -&gt; with_stamp header tags k ppf fmt
  in
  { Logs.report = report }

let main () =
  Logs.set_reporter (reporter (Format.std_formatter));
  Logs.set_level (Some Logs.Info);
  run ();
  run ();
  ()

let () = main ()</code></pre><p>Here is the standard output of a sample run of the program:</p><pre>[INFO][+000us] Starting run
[INFO][+168us] Start action 1 (10000).
[INFO][+206us] Start action 2 (20000).
[INFO][+243us] Start action 3 (40000).
[INFO][+303us] Done.
[INFO][+000us] Starting run
[INFO][+012us] Start action 1 (10000).
[INFO][+038us] Start action 2 (20000).
[INFO][+074us] Start action 3 (40000).
[INFO][+133us] Done.</pre></header></section><section><header><h2 id="ex2"><a href="#ex2" class="anchor"></a>Logging to multiple reporters</h2><p>Logging to multiple reporters can be achieved by defining a new reporter that simply forwards to them. The following example combines two reporters:</p><pre><code class="ml">let combine r1 r2 =
  let report = fun src level ~over k msgf -&gt;
    let v = r1.Logs.report src level ~over:(fun () -&gt; ()) k msgf in
    r2.Logs.report src level ~over (fun () -&gt; v) msgf
  in
  { Logs.report }

let () =
  let r1 = Logs.format_reporter () in
  let r2 = Logs_fmt.reporter () in
  Fmt_tty.setup_std_outputs ();
  Logs.set_reporter (combine r1 r2);
  Logs.err (fun m -&gt; m &quot;HEY HO!&quot;);
  ()</code></pre></header></section></div></body></html>
