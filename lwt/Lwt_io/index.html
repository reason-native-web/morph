<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_io (lwt.Lwt_io)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lwt</a> &#x00BB; Lwt_io</nav><h1>Module <code>Lwt_io</code></h1><p>Buffered byte channels</p><nav class="toc"><ul><li><a href="#types">Types</a></li><li><a href="#well-known-instances">Well-known instances</a></li><li><a href="#channels-creation/manipulation">Channels creation/manipulation</a></li><li><a href="#random-access">Random access</a></li><li><a href="#reading">Reading</a></li><li><a href="#writing">Writing</a></li><li><a href="#printing">Printing</a></li><li><a href="#utilities">Utilities</a></li><li><a href="#file-utilities">File utilities</a></li><li><a href="#input/output-of-integers">Input/output of integers</a></li><li><a href="#low-level-access-to-the-internal-buffer">Low-level access to the internal buffer</a></li><li><a href="#misc">Misc</a></li><li><a href="#deprecated">Deprecated</a></li></ul></nav></header><aside><p>A <b>channel</b> is a high-level object for performing input/output (IO). It allows to read/write from/to the outside world in an efficient way, by minimising the number of system calls.</p><p>An <b>output channel</b> is used to send data and an <b>input channel</b> is used to receive data.</p><p>If you are familiar with buffered channels you may be familiar too with the <b>flush</b> operation. Note that byte channels of this module are automatically flushed when there is nothing else to do (i.e. before the program becomes idle), so this means that you no longer have to write:</p><pre><code class="ml">eprintf &quot;log message\n&quot;;
flush stderr;</code></pre><p>to have your messages displayed.</p><p>Note about errors: input functions of this module raise <code>End_of_file</code> when the end-of-file is reached (i.e. when the read function returns <code>0</code>). Other exceptions are ones caused by the backend read/write functions, such as <code>Unix.Unix_error</code>.</p></aside><dl><dt class="spec exception" id="exception-Channel_closed"><a href="#exception-Channel_closed" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Channel_closed</span> <span class="keyword">of</span> string</code></dt><dd><p>Exception raised when a channel is closed. The parameter is a description of the channel.</p></dd></dl><section><header><h3 id="types"><a href="#types" class="anchor"></a>Types</h3></header><dl><dt class="spec type" id="type-channel"><a href="#type-channel" class="anchor"></a><code><span class="keyword">type</span> <span>'mode channel</span></code></dt><dd><p>Type of buffered byte channels</p></dd></dl><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> input</code></dt><dd><p>Input mode</p></dd></dl><dl><dt class="spec type" id="type-output"><a href="#type-output" class="anchor"></a><code><span class="keyword">type</span> output</code></dt><dd><p>Output mode</p></dd></dl><dl><dt class="spec type" id="type-mode"><a href="#type-mode" class="anchor"></a><code><span class="keyword">type</span> <span>'a mode</span></code><code> = </code><table class="variant"><tr id="type-mode.Input" class="anchored"><td class="def constructor"><a href="#type-mode.Input" class="anchor"></a><code>| </code><code><span class="constructor">Input</span> : <span><a href="index.html#type-input">input</a> <a href="index.html#type-mode">mode</a></span></code></td></tr><tr id="type-mode.Output" class="anchored"><td class="def constructor"><a href="#type-mode.Output" class="anchor"></a><code>| </code><code><span class="constructor">Output</span> : <span><a href="index.html#type-output">output</a> <a href="index.html#type-mode">mode</a></span></code></td></tr></table></dt><dd><p>Channel mode</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : <span><a href="index.html#type-input">input</a> <a href="index.html#type-mode">mode</a></span></code></dt><dd><p><code>input</code> input mode representation</p></dd></dl><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val</span> output : <span><a href="index.html#type-output">output</a> <a href="index.html#type-mode">mode</a></span></code></dt><dd><p><code>output</code> output mode representation</p></dd></dl><dl><dt class="spec type" id="type-input_channel"><a href="#type-input_channel" class="anchor"></a><code><span class="keyword">type</span> input_channel</code><code> = <span><a href="index.html#type-input">input</a> <a href="index.html#type-channel">channel</a></span></code></dt><dd><p>Type of input channels</p></dd></dl><dl><dt class="spec type" id="type-output_channel"><a href="#type-output_channel" class="anchor"></a><code><span class="keyword">type</span> output_channel</code><code> = <span><a href="index.html#type-output">output</a> <a href="index.html#type-channel">channel</a></span></code></dt><dd><p>Type of output channels</p></dd></dl><dl><dt class="spec value" id="val-mode"><a href="#val-mode" class="anchor"></a><code><span class="keyword">val</span> mode : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-mode">mode</a></span></code></dt><dd><p><code>mode ch</code> returns the mode of a channel</p></dd></dl></section><section><header><h3 id="well-known-instances"><a href="#well-known-instances" class="anchor"></a>Well-known instances</h3></header><dl><dt class="spec value" id="val-stdin"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : <a href="index.html#type-input_channel">input_channel</a></code></dt><dd><p>The standard input, it reads data from <a href="../Lwt_unix/index.html#val-stdin"><code>Lwt_unix.stdin</code></a></p></dd></dl><dl><dt class="spec value" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : <a href="index.html#type-output_channel">output_channel</a></code></dt><dd><p>The standard output, it writes data to <a href="../Lwt_unix/index.html#val-stdout"><code>Lwt_unix.stdout</code></a></p></dd></dl><dl><dt class="spec value" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : <a href="index.html#type-output_channel">output_channel</a></code></dt><dd><p>The standard output for error messages, it writes data to <a href="../Lwt_unix/index.html#val-stderr"><code>Lwt_unix.stderr</code></a></p></dd></dl><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : <a href="index.html#type-input_channel">input_channel</a></code></dt><dd><p>Inputs which returns always <code>'\x00'</code></p></dd></dl><dl><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val</span> null : <a href="index.html#type-output_channel">output_channel</a></code></dt><dd><p>Output which drops everything</p></dd></dl></section><section><header><h3 id="channels-creation/manipulation"><a href="#channels-creation/manipulation" class="anchor"></a>Channels creation/manipulation</h3></header><dl><dt class="spec value" id="val-pipe"><a href="#val-pipe" class="anchor"></a><code><span class="keyword">val</span> pipe : <span>?&#8288;in_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;out_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-input_channel">input_channel</a> * <a href="index.html#type-output_channel">output_channel</a></code></dt><dd><p><code>pipe ?in_buffer ?out_buffer ()</code> creates a pipe using <a href="../Lwt_unix/index.html#val-pipe"><code>Lwt_unix.pipe</code></a> and makes two channels from the two returned file descriptors</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;close:<span>(unit <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;seek:<span>(int64 <span>&#45;&gt;</span> Unix.seek_command <span>&#45;&gt;</span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>mode:<span><span class="type-var">'mode</span> <a href="index.html#type-mode">mode</a></span></span> <span>&#45;&gt;</span> <span>(<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'mode</span> <a href="index.html#type-channel">channel</a></span></code></dt><dd><p><code>make ?buffer ?close ~mode perform_io</code> is the main function for creating new channels.</p><dl><dt>parameter buffer</dt><dd><p>user-supplied buffer. When this argument is present, its value will be used as the buffer for the created channel. The size of buffer must conform to the limitations described in <a href="index.html#val-set_default_buffer_size"><code>set_default_buffer_size</code></a>. When this argument is not present, a new internal buffer of default size will be allocated for this channel.</p><p>Warning: do not use the same buffer for simultaneous work with more than one channel.</p><p>There are other functions in this module that take a <code>buffer</code> argument, sharing the same semantics.</p></dd></dl><dl><dt>parameter close</dt><dd><p>close function of the channel. It defaults to <code>Lwt.return</code></p></dd></dl><dl><dt>parameter seek</dt><dd><p>same meaning as <code>Unix.lseek</code></p></dd></dl><dl><dt>parameter mode</dt><dd><p>either <a href="index.html#type-input"><code>input</code></a> or <a href="index.html#type-output"><code>output</code></a></p></dd></dl><dl><dt>parameter perform_io</dt><dd><p>is the read or write function. It is called when more input is needed or when the buffer need to be flushed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : <span>mode:<span><span class="type-var">'mode</span> <a href="index.html#type-mode">mode</a></span></span> <span>&#45;&gt;</span> <a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'mode</span> <a href="index.html#type-channel">channel</a></span></code></dt><dd><p>Create a channel from a byte array. Reading/writing is done directly on the provided array.</p></dd></dl><dl><dt class="spec value" id="val-of_fd"><a href="#val-of_fd" class="anchor"></a><code><span class="keyword">val</span> of_fd : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;close:<span>(unit <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>mode:<span><span class="type-var">'mode</span> <a href="index.html#type-mode">mode</a></span></span> <span>&#45;&gt;</span> <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <span><span class="type-var">'mode</span> <a href="index.html#type-channel">channel</a></span></code></dt><dd><p><code>of_fd ?buffer ?close ~mode fd</code> creates a channel from a file descriptor.</p><dl><dt>parameter close</dt><dd><p>defaults to closing the file descriptor.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_unix_fd"><a href="#val-of_unix_fd" class="anchor"></a><code><span class="keyword">val</span> of_unix_fd : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;close:<span>(unit <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>mode:<span><span class="type-var">'mode</span> <a href="index.html#type-mode">mode</a></span></span> <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> <span><span class="type-var">'mode</span> <a href="index.html#type-channel">channel</a></span></code></dt><dd><p><code>of_unix_fd ?buffer ?close ~mode fd</code> is a short-hand for:</p><p><code>of_fd ?buffer ?close (Lwt_unix.of_unix_file_descr fd)</code></p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>close ch</code> closes the given channel. If <code>ch</code> is an output channel, it performs all pending actions, flushes it and closes it. If <code>ch</code> is an input channel, it just closes it immediately.</p><p><code>close</code> returns the result of the close function of the channel. Multiple calls to <code>close</code> will return exactly the same value.</p><p>Note: you cannot use <code>close</code> on channels obtained with <a href="index.html#val-atomic"><code>atomic</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-abort"><a href="#val-abort" class="anchor"></a><code><span class="keyword">val</span> abort : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>abort ch</code> abort current operations and close the channel immediately.</p></dd></dl><dl><dt class="spec value" id="val-atomic"><a href="#val-atomic" class="anchor"></a><code><span class="keyword">val</span> atomic : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>atomic f</code> transforms a sequence of io operations into one single atomic io operation.</p><p>Note:</p><ul><li>the channel passed to <code>f</code> is invalid after <code>f</code> terminates</li><li><code>atomic</code> can be called inside another <code>atomic</code></li></ul></dd></dl><dl><dt class="spec value" id="val-file_length"><a href="#val-file_length" class="anchor"></a><code><span class="keyword">val</span> file_length : string <span>&#45;&gt;</span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Retrieves the length of the file at the given path. If the path refers to a directory, the returned promise is rejected with <code>Unix.(Unix_error (EISDIR, _, _))</code>.</p></dd></dl><dl><dt class="spec value" id="val-buffered"><a href="#val-buffered" class="anchor"></a><code><span class="keyword">val</span> buffered : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>buffered oc</code> returns the number of bytes in the buffer</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>flush oc</code> performs all pending writes on <code>oc</code></p></dd></dl><dl><dt class="spec value" id="val-flush_all"><a href="#val-flush_all" class="anchor"></a><code><span class="keyword">val</span> flush_all : unit <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>flush_all ()</code> flushes all open output channels</p></dd></dl><dl><dt class="spec value" id="val-buffer_size"><a href="#val-buffer_size" class="anchor"></a><code><span class="keyword">val</span> buffer_size : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the size of the internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-resize_buffer"><a href="#val-resize_buffer" class="anchor"></a><code><span class="keyword">val</span> resize_buffer : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Resize the internal buffer to the given size</p></dd></dl><dl><dt class="spec value" id="val-is_busy"><a href="#val-is_busy" class="anchor"></a><code><span class="keyword">val</span> is_busy : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_busy channel</code> returns whether the given channel is currently busy. A channel is busy when there is at least one job using it that has not yet terminated.</p></dd></dl><dl><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_closed channel</code> returns whether the given channel is currently closed.</p><dl><dt>since</dt><dd>4.2.0</dd></dl></dd></dl></section><section><header><h3 id="random-access"><a href="#random-access" class="anchor"></a>Random access</h3></header><dl><dt class="spec value" id="val-position"><a href="#val-position" class="anchor"></a><code><span class="keyword">val</span> position : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> int64</code></dt><dd><p><code>position ch</code> Returns the current position in the channel.</p></dd></dl><dl><dt class="spec value" id="val-set_position"><a href="#val-set_position" class="anchor"></a><code><span class="keyword">val</span> set_position : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>set_position ch pos</code> Sets the position in the output channel. This does not work if the channel does not support random access.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Returns the length of the channel in bytes</p></dd></dl></section><section><header><h3 id="reading"><a href="#reading" class="anchor"></a>Reading</h3></header><aside><p>Note: except for functions dealing with streams (<a href="index.html#val-read_chars"><code>read_chars</code></a> and <a href="index.html#val-read_lines"><code>read_lines</code></a>) all functions are <b>atomic</b>.</p></aside><dl><dt class="spec value" id="val-read_char"><a href="#val-read_char" class="anchor"></a><code><span class="keyword">val</span> read_char : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>char <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>read_char ic</code> reads the next character of <code>ic</code>.</p><dl><dt>raises End_of_file</dt><dd><p>if the end of the file is reached</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-read_char_opt"><a href="#val-read_char_opt" class="anchor"></a><code><span class="keyword">val</span> read_char_opt : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span><span>char option</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Same as <a href="index.html#val-read_char"><code>Lwt_io.read_char</code></a>, but does not raise <code>End_of_file</code> on end of input</p></dd></dl><dl><dt class="spec value" id="val-read_chars"><a href="#val-read_chars" class="anchor"></a><code><span class="keyword">val</span> read_chars : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></code></dt><dd><p><code>read_chars ic</code> returns a stream holding all characters of <code>ic</code></p></dd></dl><dl><dt class="spec value" id="val-read_line"><a href="#val-read_line" class="anchor"></a><code><span class="keyword">val</span> read_line : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>string <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>read_line ic</code> reads one complete line from <code>ic</code> and returns it without the end of line. End of line is either <code>&quot;\n&quot;</code> or <code>&quot;\r\n&quot;</code>.</p><p>If the end of input is reached before reading any character, <code>End_of_file</code> is raised. If it is reached before reading an end of line but characters have already been read, they are returned.</p></dd></dl><dl><dt class="spec value" id="val-read_line_opt"><a href="#val-read_line_opt" class="anchor"></a><code><span class="keyword">val</span> read_line_opt : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span><span>string option</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Same as <a href="index.html#val-read_line"><code>read_line</code></a> but do not raise <code>End_of_file</code> on end of input.</p></dd></dl><dl><dt class="spec value" id="val-read_lines"><a href="#val-read_lines" class="anchor"></a><code><span class="keyword">val</span> read_lines : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></code></dt><dd><p><code>read_lines ic</code> returns a stream holding all lines of <code>ic</code></p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <span>?&#8288;count:int</span> <span>&#45;&gt;</span> <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>string <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>If <code>~count</code> is specified, <code>read ~count ic</code> reads at most <code>~count</code> characters from <code>ic</code>. Note that fewer than <code>~count</code> characters can be read; check the size of the resulting string. <code>read</code> returns <code>&quot;&quot;</code> if the end of input is reached.</p><p>If <code>~count</code> is not specified, <code>read ic</code> reads all bytes until the end of input.</p></dd></dl><dl><dt class="spec value" id="val-read_into"><a href="#val-read_into" class="anchor"></a><code><span class="keyword">val</span> read_into : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>read_into ic buffer offset length</code> reads up to <code>length</code> bytes, stores them in <code>buffer</code> at offset <code>offset</code>, and returns the number of bytes read.</p><p>Note: <code>read_into</code> does not raise <code>End_of_file</code>, it returns a length of <code>0</code> instead.</p></dd></dl><dl><dt class="spec value" id="val-read_into_exactly"><a href="#val-read_into_exactly" class="anchor"></a><code><span class="keyword">val</span> read_into_exactly : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>read_into_exactly ic buffer offset length</code> reads exactly <code>length</code> bytes and stores them in <code>buffer</code> at offset <code>offset</code>.</p><dl><dt>raises End_of_file</dt><dd><p>on end of input</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-read_value"><a href="#val-read_value" class="anchor"></a><code><span class="keyword">val</span> read_value : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>read_value channel</code> reads a marshaled value from <code>channel</code>; it corresponds to the standard library's <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALfrom_channel"><code>Marshal.from_channel</code></a>. The corresponding writing function is <a href="index.html#val-write_value"><code>write_value</code></a>.</p><p>Note that reading marshaled values is <em>not</em>, in general, type-safe. See the warning in the description of module <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html"><code>Marshal</code></a> for details. The short version is: if you read a value of one type, such as <code>string</code>, when a value of another type, such as <code>int</code> has actually been marshaled to <code>channel</code>, you may get arbitrary behavior, including segmentation faults, access violations, security bugs, etc.</p></dd></dl></section><section><header><h3 id="writing"><a href="#writing" class="anchor"></a>Writing</h3></header><aside><p>Note: as for reading functions, all functions except <a href="index.html#val-write_chars"><code>write_chars</code></a> and <a href="index.html#val-write_lines"><code>write_lines</code></a> are <b>atomic</b>.</p><p>For example if you use <a href="index.html#val-write_line"><code>write_line</code></a> in two different threads, the two operations will be serialized, and lines cannot be mixed.</p></aside><dl><dt class="spec value" id="val-write_char"><a href="#val-write_char" class="anchor"></a><code><span class="keyword">val</span> write_char : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_char oc char</code> writes <code>char</code> on <code>oc</code></p></dd></dl><dl><dt class="spec value" id="val-write_chars"><a href="#val-write_chars" class="anchor"></a><code><span class="keyword">val</span> write_chars : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_chars oc chars</code> writes all characters of <code>chars</code> on <code>oc</code></p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write oc str</code> writes all characters of <code>str</code> on <code>oc</code></p></dd></dl><dl><dt class="spec value" id="val-write_line"><a href="#val-write_line" class="anchor"></a><code><span class="keyword">val</span> write_line : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_line oc str</code> writes <code>str</code> on <code>oc</code> followed by a new-line.</p></dd></dl><dl><dt class="spec value" id="val-write_lines"><a href="#val-write_lines" class="anchor"></a><code><span class="keyword">val</span> write_lines : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_lines oc lines</code> writes all lines of <code>lines</code> to <code>oc</code></p></dd></dl><dl><dt class="spec value" id="val-write_from"><a href="#val-write_from" class="anchor"></a><code><span class="keyword">val</span> write_from : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_from oc buffer offset length</code> writes up to <code>length</code> bytes to <code>oc</code>, from <code>buffer</code> at offset <code>offset</code> and returns the number of bytes actually written</p></dd></dl><dl><dt class="spec value" id="val-write_from_string"><a href="#val-write_from_string" class="anchor"></a><code><span class="keyword">val</span> write_from_string : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>See <a href="index.html#val-write"><code>write</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-write_from_exactly"><a href="#val-write_from_exactly" class="anchor"></a><code><span class="keyword">val</span> write_from_exactly : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_from_exactly oc buffer offset length</code> writes all <code>length</code> bytes from <code>buffer</code> at offset <code>offset</code> to <code>oc</code></p></dd></dl><dl><dt class="spec value" id="val-write_from_string_exactly"><a href="#val-write_from_string_exactly" class="anchor"></a><code><span class="keyword">val</span> write_from_string_exactly : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>See <a href="index.html#val-write_from_exactly"><code>write_from_exactly</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-write_value"><a href="#val-write_value" class="anchor"></a><code><span class="keyword">val</span> write_value : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span>?&#8288;flags:<span>Stdlib.Marshal.extern_flags list</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>write_value channel ?flags v</code> writes <code>v</code> to <code>channel</code> using the <code>Marshal</code> module of the standard library. See <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALto_channel"><code>Marshal.to_channel</code></a> for an explanation of <code>?flags</code>.</p><p>The corresponding reading function is <a href="index.html#val-read_value"><code>read_value</code></a>. See warnings about type safety in the description of <a href="index.html#val-read_value"><code>read_value</code></a>.</p></dd></dl></section><section><header><h3 id="printing"><a href="#printing" class="anchor"></a>Printing</h3></header><aside><p>These functions are basically helpers. Also you may prefer using the name <a href="index.html#val-printl"><code>printl</code></a> rather than <a href="index.html#val-write_line"><code>write_line</code></a> because it is shorter.</p><p>The general name of a printing function is <code>&lt;prefix&gt;print&lt;suffixes&gt;</code>,</p><p>where <code>&lt;prefix&gt;</code> is one of:</p><ul><li><code>'f'</code>, which means that the function takes as argument a channel</li><li>nothing, which means that the function prints on <a href="index.html#val-stdout"><code>stdout</code></a></li><li><code>'e'</code>, which means that the function prints on <a href="index.html#val-stderr"><code>stderr</code></a></li></ul><p>and <code>&lt;suffixes&gt;</code> is a combination of:</p><ul><li><code>'l'</code> which means that a new-line character is printed after the message</li><li><code>'f'</code> which means that the function takes as argument a <b>format</b> instead of a string</li></ul></aside><dl><dt class="spec value" id="val-fprint"><a href="#val-fprint" class="anchor"></a><code><span class="keyword">val</span> fprint : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-fprintl"><a href="#val-fprintl" class="anchor"></a><code><span class="keyword">val</span> fprintl : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-fprintf"><a href="#val-fprintf" class="anchor"></a><code><span class="keyword">val</span> fprintf : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, unit, string, <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.flush channel</code>.</p></dd></dl><dl><dt class="spec value" id="val-fprintlf"><a href="#val-fprintlf" class="anchor"></a><code><span class="keyword">val</span> fprintlf : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, unit, string, <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.flush channel</code>.</p></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-printl"><a href="#val-printl" class="anchor"></a><code><span class="keyword">val</span> printl : string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-printf"><a href="#val-printf" class="anchor"></a><code><span class="keyword">val</span> printf : <span><span>(<span class="type-var">'a</span>, unit, string, <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stdout)</code>.</p></dd></dl><dl><dt class="spec value" id="val-printlf"><a href="#val-printlf" class="anchor"></a><code><span class="keyword">val</span> printlf : <span><span>(<span class="type-var">'a</span>, unit, string, <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stdout)</code>.</p></dd></dl><dl><dt class="spec value" id="val-eprint"><a href="#val-eprint" class="anchor"></a><code><span class="keyword">val</span> eprint : string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-eprintl"><a href="#val-eprintl" class="anchor"></a><code><span class="keyword">val</span> eprintl : string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-eprintf"><a href="#val-eprintf" class="anchor"></a><code><span class="keyword">val</span> eprintf : <span><span>(<span class="type-var">'a</span>, unit, string, <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stderr)</code>.</p></dd></dl><dl><dt class="spec value" id="val-eprintlf"><a href="#val-eprintlf" class="anchor"></a><code><span class="keyword">val</span> eprintlf : <span><span>(<span class="type-var">'a</span>, unit, string, <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stderr)</code>.</p></dd></dl></section><section><header><h3 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h3></header><dl><dt class="spec value" id="val-hexdump_stream"><a href="#val-hexdump_stream" class="anchor"></a><code><span class="keyword">val</span> hexdump_stream : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>hexdump_stream oc byte_stream</code> produces the same output as the command <code>hexdump -C</code>.</p></dd></dl><dl><dt class="spec value" id="val-hexdump"><a href="#val-hexdump" class="anchor"></a><code><span class="keyword">val</span> hexdump : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>hexdump oc str = hexdump_stream oc (Lwt_stream.of_string str)</code></p></dd></dl></section><section><header><h3 id="file-utilities"><a href="#file-utilities" class="anchor"></a>File utilities</h3></header><dl><dt class="spec type" id="type-file_name"><a href="#type-file_name" class="anchor"></a><code><span class="keyword">type</span> file_name</code><code> = string</code></dt><dd><p>Type of file names</p></dd></dl><dl><dt class="spec value" id="val-open_file"><a href="#val-open_file" class="anchor"></a><code><span class="keyword">val</span> open_file : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:<span>Unix.open_flag list</span></span> <span>&#45;&gt;</span> <span>?&#8288;perm:Unix.file_perm</span> <span>&#45;&gt;</span> <span>mode:<span><span class="type-var">'a</span> <a href="index.html#type-mode">mode</a></span></span> <span>&#45;&gt;</span> <a href="index.html#type-file_name">file_name</a> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>Lwt_io.open_file ~mode file</code> opens the given file, either for reading (with <code>~mode:Input</code>) or for writing (with <code>~mode:Output</code>). The returned channel provides buffered I/O on the file.</p><p>If <code>~buffer</code> is supplied, it is used as the I/O buffer.</p><p>If <code>~flags</code> is supplied, the file is opened with the given flags (see <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEopen_flag"><code>Unix.open_flag</code></a>). Note that <code>~flags</code> is used <em>exactly</em> as given. For example, opening a file with <code>~flags</code> and <code>~mode:Input</code> does <em>not</em> implicitly add <code>O_RDONLY</code>. So, you should include <code>O_RDONLY</code> when opening for reading (<code>~mode:Input</code>), and <code>O_WRONLY</code> when opening for writing (<code>~mode:Input</code>). It is also recommended to include <code>O_NONBLOCK</code>, unless you are sure that the file cannot be a socket or a named pipe.</p><p>The default permissions used for creating new files are <code>0o666</code>, i.e. reading and writing are allowed for the file owner, group, and everyone. These default permissions can be overridden by supplying <code>~perm</code>.</p><p>Note: if opening for writing (<code>~mode:Output</code>), and the file already exists, <code>open_file</code> truncates (clears) the file by default. If you would like to keep the pre-existing contents of the file, use the <code>~flags</code> parameter to pass a custom flags list that does not include <code>Unix.O_TRUNC</code>.</p><dl><dt>raises Unix.Unix_error</dt><dd><p>on error.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-with_file"><a href="#val-with_file" class="anchor"></a><code><span class="keyword">val</span> with_file : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:<span>Unix.open_flag list</span></span> <span>&#45;&gt;</span> <span>?&#8288;perm:Unix.file_perm</span> <span>&#45;&gt;</span> <span>mode:<span><span class="type-var">'a</span> <a href="index.html#type-mode">mode</a></span></span> <span>&#45;&gt;</span> <a href="index.html#type-file_name">file_name</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>Lwt_io.with_file ~mode filename f</code> opens the given using <a href="index.html#val-open_file"><code>Lwt_io.open_file</code></a>, and passes the resulting channel to <code>f</code>. <code>Lwt_io.with_file</code> ensures that the channel is closed when the promise returned by <code>f</code> resolves, or if <code>f</code> raises an exception.</p><p>See <a href="index.html#val-open_file"><code>Lwt_io.open_file</code></a> for a description of the arguments, warnings, and other notes.</p></dd></dl><dl><dt class="spec value" id="val-open_temp_file"><a href="#val-open_temp_file" class="anchor"></a><code><span class="keyword">val</span> open_temp_file : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:<span>Unix.open_flag list</span></span> <span>&#45;&gt;</span> <span>?&#8288;perm:Unix.file_perm</span> <span>&#45;&gt;</span> <span>?&#8288;temp_dir:string</span> <span>&#45;&gt;</span> <span>?&#8288;prefix:string</span> <span>&#45;&gt;</span> <span>?&#8288;suffix:string</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(string * <a href="index.html#type-output_channel">output_channel</a>)</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>open_temp_file ()</code> starts creating a new temporary file, and evaluates to a promise for the pair of the file's name, and an output channel for writing to the file.</p><p>The caller should take care to delete the file later. Alternatively, see <a href="index.html#val-with_temp_file"><code>Lwt_io.with_temp_file</code></a>.</p><p>The <code>?buffer</code> and <code>?perm</code> arguments are passed directly to an internal call to <a href="index.html#val-open_file"><code>Lwt_io.open_file</code></a>.</p><p>If not specified, <code>?flags</code> defaults to <code>[O_CREATE; O_EXCL; O_WRONLY; O_CLOEXEC]</code>. If specified, the specified flags are used exactly. Note that these should typically contain at least <code>O_CREAT</code> and <code>O_EXCL</code>, otherwise <code>open_temp_file</code> may open an existing file.</p><p><code>?temp_dir</code> can be used to choose the directory in which the file is created. For the current directory, use <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALcurrent_dir_name"><code>Filename.current_dir_name</code></a>. If not specified, the directory is taken from <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALget_temp_dir_name"><code>Filename.get_temp_dir_name</code></a>, which is typically set to your system temporary file directory.</p><p><code>?prefix</code> helps determine the name of the file. It will be the prefix concatenated with a random sequence of characters. If not specified, <code>open_temp_file</code> uses some default prefix.</p><p><code>?suffix</code> is like <code>prefix</code>, but it is appended at the end of the filename. In particular, it can be used to set the extension. This argument is supported since Lwt 4.4.0.</p><dl><dt>since</dt><dd>3.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-with_temp_file"><a href="#val-with_temp_file" class="anchor"></a><code><span class="keyword">val</span> with_temp_file : <span>?&#8288;buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:<span>Unix.open_flag list</span></span> <span>&#45;&gt;</span> <span>?&#8288;perm:Unix.file_perm</span> <span>&#45;&gt;</span> <span>?&#8288;temp_dir:string</span> <span>&#45;&gt;</span> <span>?&#8288;prefix:string</span> <span>&#45;&gt;</span> <span>?&#8288;suffix:string</span> <span>&#45;&gt;</span> <span>(<span>(string * <a href="index.html#type-output_channel">output_channel</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>with_temp_file f</code> calls <a href="index.html#val-open_temp_file"><code>open_temp_file</code></a><code> ()</code>, passing all optional arguments directly to it. It then attaches <code>f</code> to run after the file is created, passing the filename and output channel to <code>f</code>. When the promise returned by <code>f</code> is resolved, <code>with_temp_file</code> closes the channel and deletes the temporary file by calling <a href="../Lwt_unix/index.html#val-unlink"><code>Lwt_unix.unlink</code></a>.</p><dl><dt>since</dt><dd>3.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-create_temp_dir"><a href="#val-create_temp_dir" class="anchor"></a><code><span class="keyword">val</span> create_temp_dir : <span>?&#8288;perm:Unix.file_perm</span> <span>&#45;&gt;</span> <span>?&#8288;parent:string</span> <span>&#45;&gt;</span> <span>?&#8288;prefix:string</span> <span>&#45;&gt;</span> <span>?&#8288;suffix:string</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span>string <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Creates a temporary directory, and returns a promise that resolves to its path. The caller must take care to remove the directory. Alternatively, see <a href="index.html#val-with_temp_dir"><code>Lwt_io.with_temp_dir</code></a>.</p><p>If <code>~perm</code> is specified, the directory is created with the given permissions. The default permissions are <code>0755</code>.</p><p><code>~parent</code> is the directory in which the temporary directory is created. If not specified, the default value is the result of <code>Filename.get_temp_dir_name ()</code>.</p><p><code>~prefix</code> is prepended to the directory name, and <code>~suffix</code> is appended to it.</p><dl><dt>since</dt><dd>4.4.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-with_temp_dir"><a href="#val-with_temp_dir" class="anchor"></a><code><span class="keyword">val</span> with_temp_dir : <span>?&#8288;perm:Unix.file_perm</span> <span>&#45;&gt;</span> <span>?&#8288;parent:string</span> <span>&#45;&gt;</span> <span>?&#8288;prefix:string</span> <span>&#45;&gt;</span> <span>?&#8288;suffix:string</span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>with_temp_dir f</code> first calls <a href="index.html#val-create_temp_dir"><code>create_temp_dir</code></a>, forwarding all optional arguments to it. Once the temporary directory is created at <code>path</code>, <code>with_temp_dir f</code> calls <code>f path</code>. When the promise returned by <code>f path</code> is resolved, <code>with_temp_dir f</code> recursively deletes the temporary directory and all its contents.</p><dl><dt>since</dt><dd>4.4.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-open_connection"><a href="#val-open_connection" class="anchor"></a><code><span class="keyword">val</span> open_connection : <span>?&#8288;fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>?&#8288;in_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;out_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-input_channel">input_channel</a> * <a href="index.html#type-output_channel">output_channel</a>)</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>open_connection ?fd ?in_buffer ?out_buffer addr</code> opens a connection to the given address and returns two channels for using it. If <code>fd</code> is not specified, a fresh one will be used.</p><p>The connection is completely closed when you close both channels.</p><dl><dt>raises Unix.Unix_error</dt><dd><p>on error.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-with_connection"><a href="#val-with_connection" class="anchor"></a><code><span class="keyword">val</span> with_connection : <span>?&#8288;fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>?&#8288;in_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;out_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a></span> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> <span>(<span>(<a href="index.html#type-input_channel">input_channel</a> * <a href="index.html#type-output_channel">output_channel</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>with_connection ?fd ?in_buffer ?out_buffer addr f</code> opens a connection to the given address and passes the channels to <code>f</code></p></dd></dl><dl><dt class="spec type" id="type-server"><a href="#type-server" class="anchor"></a><code><span class="keyword">type</span> server</code></dt><dd><p>Type of a server</p></dd></dl><dl><dt class="spec value" id="val-establish_server_with_client_socket"><a href="#val-establish_server_with_client_socket" class="anchor"></a><code><span class="keyword">val</span> establish_server_with_client_socket : <span>?&#8288;server_fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>?&#8288;backlog:int</span> <span>&#45;&gt;</span> <span>?&#8288;no_close:bool</span> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> <span>(<a href="../Lwt_unix/index.html#type-sockaddr">Lwt_unix.sockaddr</a> <span>&#45;&gt;</span> <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-server">server</a> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>establish_server_with_client_socket listen_address f</code> creates a server which listens for incoming connections on <code>listen_address</code>. When a client makes a new connection, it is passed to <code>f</code>: more precisely, the server calls</p><pre><code class="ml">f client_address client_socket</code></pre><p>where <code>client_address</code> is the address (peer name) of the new client, and <code>client_socket</code> is the socket connected to the client.</p><p>The server does not block waiting for <code>f</code> to complete: it concurrently tries to accept more client connections while <code>f</code> is handling the client.</p><p>When the promise returned by <code>f</code> completes (i.e., <code>f</code> is done handling the client), <code>establish_server_with_client_socket</code> automatically closes <code>client_socket</code>. This is a default behavior that is useful for simple cases, but for a robust application you should explicitly close these channels yourself, and handle any exceptions as appropriate. If the channels are still open when <code>f</code> completes, and their automatic closing raises an exception, <code>establish_server_with_client_socket</code> treats it as an unhandled exception reaching the top level of the application: it passes that exception to <a href="../Lwt/index.html#val-async_exception_hook"><code>Lwt.async_exception_hook</code></a>, the default behavior of which is to print the exception and <em>terminate your process</em>.</p><p>Automatic closing can be completely disabled by passing <code>~no_close:true</code>.</p><p>Similarly, if <code>f</code> raises an exception (or the promise it returns fails with an exception), <code>establish_server_with_client_socket</code> can do nothing with that exception, except pass it to <a href="../Lwt/index.html#val-async_exception_hook"><code>Lwt.async_exception_hook</code></a>.</p><p><code>~server_fd</code> can be specified to use an existing file descriptor for listening. Otherwise, a fresh socket is created internally. In either case, <code>establish_server_with_client_socket</code> will internally assign <code>listen_address</code> to the server socket.</p><p><code>~backlog</code> is the argument passed to <a href="../Lwt_unix/index.html#val-listen"><code>Lwt_unix.listen</code></a>. Its default value is <code>SOMAXCONN</code>, which varies by platform and socket kind.</p><p>The returned promise (a <code>server Lwt.t</code>) resolves when the server has just started listening on <code>listen_address</code>: right after the internal call to <code>listen</code>, and right before the first internal call to <code>accept</code>.</p><dl><dt>since</dt><dd>4.1.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-establish_server_with_client_address"><a href="#val-establish_server_with_client_address" class="anchor"></a><code><span class="keyword">val</span> establish_server_with_client_address : <span>?&#8288;fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>?&#8288;buffer_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;backlog:int</span> <span>&#45;&gt;</span> <span>?&#8288;no_close:bool</span> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> <span>(<a href="../Lwt_unix/index.html#type-sockaddr">Lwt_unix.sockaddr</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-input_channel">input_channel</a> * <a href="index.html#type-output_channel">output_channel</a>)</span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-server">server</a> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Like <a href="index.html#val-establish_server_with_client_socket"><code>Lwt_io.establish_server_with_client_socket</code></a>, but passes two buffered channels to the connection handler <code>f</code>. These channels wrap the client socket.</p><p>The channels are closed automatically when the promise returned by <code>f</code> resolves. To avoid this behavior, pass <code>~no_close:true</code>.</p><dl><dt>since</dt><dd>3.1.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-shutdown_server"><a href="#val-shutdown_server" class="anchor"></a><code><span class="keyword">val</span> shutdown_server : <a href="index.html#type-server">server</a> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Closes the given server's listening socket. The returned promise resolves when the <code>close(2)</code> system call completes. This function does not affect the sockets of connections that have already been accepted, i.e. passed to <code>f</code> by <a href="index.html#val-establish_server"><code>establish_server</code></a>.</p><dl><dt>since</dt><dd>3.0.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-lines_of_file"><a href="#val-lines_of_file" class="anchor"></a><code><span class="keyword">val</span> lines_of_file : <a href="index.html#type-file_name">file_name</a> <span>&#45;&gt;</span> <span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></code></dt><dd><p><code>lines_of_file name</code> returns a stream of all lines of the file with name <code>name</code>. The file is automatically closed when all lines have been read.</p></dd></dl><dl><dt class="spec value" id="val-lines_to_file"><a href="#val-lines_to_file" class="anchor"></a><code><span class="keyword">val</span> lines_to_file : <a href="index.html#type-file_name">file_name</a> <span>&#45;&gt;</span> <span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>lines_to_file name lines</code> writes all lines of <code>lines</code> to file with name <code>name</code>.</p></dd></dl><dl><dt class="spec value" id="val-chars_of_file"><a href="#val-chars_of_file" class="anchor"></a><code><span class="keyword">val</span> chars_of_file : <a href="index.html#type-file_name">file_name</a> <span>&#45;&gt;</span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></code></dt><dd><p><code>chars_of_file name</code> returns a stream of all characters of the file with name <code>name</code>. As for <a href="index.html#val-lines_of_file"><code>lines_of_file</code></a> the file is closed when all characters have been read.</p></dd></dl><dl><dt class="spec value" id="val-chars_to_file"><a href="#val-chars_to_file" class="anchor"></a><code><span class="keyword">val</span> chars_to_file : <a href="index.html#type-file_name">file_name</a> <span>&#45;&gt;</span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>chars_to_file name chars</code> writes all characters of <code>chars</code> to <code>name</code></p></dd></dl></section><section><header><h3 id="input/output-of-integers"><a href="#input/output-of-integers" class="anchor"></a>Input/output of integers</h3></header><dl><dt class="spec module-type" id="module-type-NumberIO"><a href="#module-type-NumberIO" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NumberIO/index.html">NumberIO</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Common interface for reading/writing integers in binary</p></dd></dl><dl><dt class="spec module" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <a href="index.html#module-type-NumberIO">NumberIO</a></code></dt><dd><p>Reading/writing of numbers in little-endian</p></dd></dl><dl><dt class="spec module" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <a href="index.html#module-type-NumberIO">NumberIO</a></code></dt><dd><p>Reading/writing of numbers in big-endian</p></dd></dl><div><div class="spec include"><div class="doc"><p>Reading/writing of numbers in the system endianness.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-type-NumberIO">NumberIO</a></code></span></summary><dl><dt class="spec value" id="val-read_int"><a href="#val-read_int" class="anchor"></a><code><span class="keyword">val</span> read_int : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Reads a 32-bits integer as an ocaml int</p></dd></dl><dl><dt class="spec value" id="val-read_int16"><a href="#val-read_int16" class="anchor"></a><code><span class="keyword">val</span> read_int16 : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-read_int32"><a href="#val-read_int32" class="anchor"></a><code><span class="keyword">val</span> read_int32 : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>int32 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-read_int64"><a href="#val-read_int64" class="anchor"></a><code><span class="keyword">val</span> read_int64 : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-read_float32"><a href="#val-read_float32" class="anchor"></a><code><span class="keyword">val</span> read_float32 : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>float <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Reads an IEEE single precision floating point value</p></dd></dl><dl><dt class="spec value" id="val-read_float64"><a href="#val-read_float64" class="anchor"></a><code><span class="keyword">val</span> read_float64 : <a href="index.html#type-input_channel">input_channel</a> <span>&#45;&gt;</span> <span>float <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Reads an IEEE double precision floating point value</p></dd></dl><section><header><h4 id="writing"><a href="#writing" class="anchor"></a>Writing</h4></header><dl><dt class="spec value" id="val-write_int"><a href="#val-write_int" class="anchor"></a><code><span class="keyword">val</span> write_int : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Writes an ocaml int as a 32-bits integer</p></dd></dl><dl><dt class="spec value" id="val-write_int16"><a href="#val-write_int16" class="anchor"></a><code><span class="keyword">val</span> write_int16 : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-write_int32"><a href="#val-write_int32" class="anchor"></a><code><span class="keyword">val</span> write_int32 : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-write_int64"><a href="#val-write_int64" class="anchor"></a><code><span class="keyword">val</span> write_int64 : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-write_float32"><a href="#val-write_float32" class="anchor"></a><code><span class="keyword">val</span> write_float32 : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Writes an IEEE single precision floating point value</p></dd></dl><dl><dt class="spec value" id="val-write_float64"><a href="#val-write_float64" class="anchor"></a><code><span class="keyword">val</span> write_float64 : <a href="index.html#type-output_channel">output_channel</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Writes an IEEE double precision floating point value</p></dd></dl></section></details></div></div></div><dl><dt class="spec type" id="type-byte_order"><a href="#type-byte_order" class="anchor"></a><code><span class="keyword">type</span> byte_order</code><code> = <a href="../Lwt_sys/index.html#type-byte_order">Lwt_sys.byte_order</a></code><code> = </code><table class="variant"><tr id="type-byte_order.Little_endian" class="anchored"><td class="def constructor"><a href="#type-byte_order.Little_endian" class="anchor"></a><code>| </code><code><span class="constructor">Little_endian</span></code></td></tr><tr id="type-byte_order.Big_endian" class="anchored"><td class="def constructor"><a href="#type-byte_order.Big_endian" class="anchor"></a><code>| </code><code><span class="constructor">Big_endian</span></code></td><td class="doc"><p>Type of byte order</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-system_byte_order"><a href="#val-system_byte_order" class="anchor"></a><code><span class="keyword">val</span> system_byte_order : <a href="index.html#type-byte_order">byte_order</a></code></dt><dd><p>Same as <a href="../Lwt_sys/index.html#type-byte_order"><code>Lwt_sys.byte_order</code></a>.</p></dd></dl></section><section><header><h3 id="low-level-access-to-the-internal-buffer"><a href="#low-level-access-to-the-internal-buffer" class="anchor"></a>Low-level access to the internal buffer</h3></header><dl><dt class="spec value" id="val-block"><a href="#val-block" class="anchor"></a><code><span class="keyword">val</span> block : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>block ch size f</code> pass to <code>f</code> the internal buffer and an offset. The buffer contains <code>size</code> chars at <code>offset</code>. <code>f</code> may read or write these chars. <code>size</code> must satisfy <code>0 &lt;= size &lt;= 16</code></p></dd></dl><dl><dt class="spec type" id="type-direct_access"><a href="#type-direct_access" class="anchor"></a><code><span class="keyword">type</span> direct_access</code><code> = </code><code>{</code><table class="record"><tr id="type-direct_access.da_buffer" class="anchored"><td class="def field"><a href="#type-direct_access.da_buffer" class="anchor"></a><code>da_buffer : <a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a>;</code></td><td class="doc"><p>The internal buffer</p></td></tr><tr id="type-direct_access.da_ptr" class="anchored"><td class="def field"><a href="#type-direct_access.da_ptr" class="anchor"></a><code><span class="keyword">mutable</span> da_ptr : int;</code></td><td class="doc"><p>The pointer to:</p><ul><li>the beginning of free space for output channels</li><li>the beginning of data for input channels</li></ul></td></tr><tr id="type-direct_access.da_max" class="anchored"><td class="def field"><a href="#type-direct_access.da_max" class="anchor"></a><code><span class="keyword">mutable</span> da_max : int;</code></td><td class="doc"><p>The maximum offset</p></td></tr><tr id="type-direct_access.da_perform" class="anchored"><td class="def field"><a href="#type-direct_access.da_perform" class="anchor"></a><code>da_perform : unit <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span>;</code></td><td class="doc"><ul><li>for input channels: refills the buffer and returns how many bytes have been read</li><li>for output channels: flush partially the buffer and returns how many bytes have been written</li></ul></td></tr></table><code>}</code></dt><dd><p>Information for directly accessing the internal buffer of a channel</p></dd></dl><dl><dt class="spec value" id="val-direct_access"><a href="#val-direct_access" class="anchor"></a><code><span class="keyword">val</span> direct_access : <span><span class="type-var">'a</span> <a href="index.html#type-channel">channel</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-direct_access">direct_access</a> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>direct_access ch f</code> passes to <code>f</code> a <a href="index.html#type-direct_access"><code>direct_access</code></a> structure. <code>f</code> must use it and update <code>da_ptr</code> to reflect how many bytes have been read/written.</p></dd></dl></section><section><header><h3 id="misc"><a href="#misc" class="anchor"></a>Misc</h3></header><dl><dt class="spec value" id="val-default_buffer_size"><a href="#val-default_buffer_size" class="anchor"></a><code><span class="keyword">val</span> default_buffer_size : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Return the default size for buffers. Channels that are created without a specific buffer use new buffer of this size.</p></dd></dl><dl><dt class="spec value" id="val-set_default_buffer_size"><a href="#val-set_default_buffer_size" class="anchor"></a><code><span class="keyword">val</span> set_default_buffer_size : int <span>&#45;&gt;</span> unit</code></dt><dd><p>Change the default buffer size.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the given size is smaller than <code>16</code> or greater than <code>Sys.max_string_length</code></p></dd></dl></dd></dl></section><section><header><h3 id="deprecated"><a href="#deprecated" class="anchor"></a>Deprecated</h3></header><dl><dt class="spec value" id="val-establish_server"><a href="#val-establish_server" class="anchor"></a><code><span class="keyword">val</span> establish_server : <span>?&#8288;fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>?&#8288;buffer_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;backlog:int</span> <span>&#45;&gt;</span> <span>?&#8288;no_close:bool</span> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> <span>(<span>(<a href="index.html#type-input_channel">input_channel</a> * <a href="index.html#type-output_channel">output_channel</a>)</span> <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-server">server</a> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Like <code>establish_server_with_client_address</code>, but does not pass the client address or fd to the callback <code>f</code>.</p><dl><dt>deprecated</dt><dd><p>Use <a href="index.html#val-establish_server_with_client_address"><code>establish_server_with_client_address</code></a>.</p></dd></dl><dl><dt>since</dt><dd>3.0.0</dd></dl></dd></dl><dl><dt class="spec module" id="module-Versioned"><a href="#module-Versioned" class="anchor"></a><code><span class="keyword">module</span> <a href="Versioned/index.html">Versioned</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Versioned variants of APIs undergoing breaking changes.</p></dd></dl></section></div></body></html>